//
// GENERATED by ll1gen : Do not modify (or on your own risk)
//
#ifndef _LL1GEN_GLOSSARYENTRY_HPP_
#define _LL1GEN_GLOSSARYENTRY_HPP_

#include "json_utils.hpp"

//ll1gen::include_begin

#include "glossarydefinition.hpp"
//ll1gen::include_end

namespace test { namespace glossary { 

class GlossaryEntry {
public:
    //ll1gen::constructor_begin
    GlossaryEntry(
    		    const std::string & __ID

,
    const std::string & __SortAs

,
    const std::string & __GlossTerm

,
    const std::string & __Acronym

,
    const std::string & __Abbrev

,
    const GlossaryDefinition & __GlossDef

,
    const std::string & __GlossSee

//ll1gen::constructor_param
              ) :
    		    _ID(__ID)

,
    _SortAs(__SortAs)

,
    _GlossTerm(__GlossTerm)

,
    _Acronym(__Acronym)

,
    _Abbrev(__Abbrev)

,
    _GlossDef(__GlossDef)

,
    _GlossSee(__GlossSee)

//ll1gen::constructor_assign
		{}
    //ll1gen::constructor_begin

    //ll1gen::copy_constructor_begin
    GlossaryEntry(const GlossaryEntry & __bean) :
    		    _ID(__bean._ID)

,
    _SortAs(__bean._SortAs)

,
    _GlossTerm(__bean._GlossTerm)

,
    _Acronym(__bean._Acronym)

,
    _Abbrev(__bean._Abbrev)

,
    _GlossDef(__bean._GlossDef)

,
    _GlossSee(__bean._GlossSee)

//ll1gen::copy_constructor_assign
		{}
    //ll1gen::copy_constructor_end

    GlossaryEntry() {}
    virtual ~GlossaryEntry() {}

    //ll1gen::getters_begin

    
    const std::string & getID() const { return _ID; }

    void setID( const std::string & __val) { _ID = __val; }



    const std::string & getSortAs() const { return _SortAs; }

    void setSortAs( const std::string & __val) { _SortAs = __val; }



    const std::string & getGlossTerm() const { return _GlossTerm; }

    void setGlossTerm( const std::string & __val) { _GlossTerm = __val; }



    const std::string & getAcronym() const { return _Acronym; }

    void setAcronym( const std::string & __val) { _Acronym = __val; }



    const std::string & getAbbrev() const { return _Abbrev; }

    void setAbbrev( const std::string & __val) { _Abbrev = __val; }



    const GlossaryDefinition & getGlossDef() const { return _GlossDef; }

    void setGlossDef( const GlossaryDefinition & __val) { _GlossDef = __val; }



    const std::string & getGlossSee() const { return _GlossSee; }

    void setGlossSee( const std::string & __val) { _GlossSee = __val; }


//ll1gen::getters_end

    GlossaryEntry & operator = (const GlossaryEntry & __bean) {
        if(this != &__bean) {
    		    this->_ID = __bean._ID;

    this->_SortAs = __bean._SortAs;

    this->_GlossTerm = __bean._GlossTerm;

    this->_Acronym = __bean._Acronym;

    this->_Abbrev = __bean._Abbrev;

    this->_GlossDef = __bean._GlossDef;

    this->_GlossSee = __bean._GlossSee;

//ll1gen::opeq_assign
        }
        return (*this);
    }

    friend std::ostream& operator<< (std::ostream& __stream, const GlossaryEntry& __bean);
    friend std::istream& operator>> (std::istream& __stream, GlossaryEntry& __bean);
private:
    //ll1gen::field_decl_begin

    std::string _ID;
std::string _SortAs;
std::string _GlossTerm;
std::string _Acronym;
std::string _Abbrev;
GlossaryDefinition _GlossDef;
std::string _GlossSee;
//ll1gen::field_decl_end
};

std::ostream& operator<< (std::ostream& __stream, const GlossaryEntry& __bean) {
    __stream << "{";
    //ll1gen::field_ostream_begin

        __stream << "\"ID\":\"" << ll1gen::json::detail::encodeJsonString(__bean._ID) << "\"";


__stream << ",";
    __stream << "\"SortAs\":\"" << ll1gen::json::detail::encodeJsonString(__bean._SortAs) << "\"";


__stream << ",";
    __stream << "\"GlossTerm\":\"" << ll1gen::json::detail::encodeJsonString(__bean._GlossTerm) << "\"";


__stream << ",";
    __stream << "\"Acronym\":\"" << ll1gen::json::detail::encodeJsonString(__bean._Acronym) << "\"";


__stream << ",";
    __stream << "\"Abbrev\":\"" << ll1gen::json::detail::encodeJsonString(__bean._Abbrev) << "\"";


__stream << ",";
    __stream << "\"GlossDef\":" << __bean._GlossDef;


__stream << ",";
    __stream << "\"GlossSee\":\"" << ll1gen::json::detail::encodeJsonString(__bean._GlossSee) << "\"";


//ll1gen::field_ostream_end
    __stream << "}";
    return __stream;
}

std::istream& operator>> (std::istream& __stream, GlossaryEntry& __bean) {
    char __startObjectMrk = ll1gen::json::detail::lookUpAndEat(__stream, "{n");
    if(__startObjectMrk == 'n') {
        ll1gen::json::detail::lookUpTokenRemainder(__stream, __startObjectMrk, "null");
        return __stream;
    }
    for(unsigned int __i = 0; __i < 7; ++__i) {
        ll1gen::json::detail::lookUpAndEat(__stream, "\"");
        std::string __propertyName = ll1gen::json::detail::lookUp(__stream, "\"");
        ll1gen::json::detail::lookUpAndEat(__stream, ":");

        //ll1gen::field_istream_begin

            if(__propertyName == "ID") {
        if(!ll1gen::json::detail::parseString(__stream, __bean._ID)) {
            throw new std::runtime_error("JSON: null not supported for field ID (string). Check definition.");
        }
    }

else
    if(__propertyName == "SortAs") {
        if(!ll1gen::json::detail::parseString(__stream, __bean._SortAs)) {
            throw new std::runtime_error("JSON: null not supported for field SortAs (string). Check definition.");
        }
    }

else
    if(__propertyName == "GlossTerm") {
        if(!ll1gen::json::detail::parseString(__stream, __bean._GlossTerm)) {
            throw new std::runtime_error("JSON: null not supported for field GlossTerm (string). Check definition.");
        }
    }

else
    if(__propertyName == "Acronym") {
        if(!ll1gen::json::detail::parseString(__stream, __bean._Acronym)) {
            throw new std::runtime_error("JSON: null not supported for field Acronym (string). Check definition.");
        }
    }

else
    if(__propertyName == "Abbrev") {
        if(!ll1gen::json::detail::parseString(__stream, __bean._Abbrev)) {
            throw new std::runtime_error("JSON: null not supported for field Abbrev (string). Check definition.");
        }
    }

else
    if(__propertyName == "GlossDef") {
        if(!ll1gen::json::detail::lookUpNull(__stream)) {
            __stream >> __bean._GlossDef;
        } else {
            throw std::runtime_error("JSON: null not supported for field GlossDef. Check definition");
        }
    }

else
    if(__propertyName == "GlossSee") {
        if(!ll1gen::json::detail::parseString(__stream, __bean._GlossSee)) {
            throw new std::runtime_error("JSON: null not supported for field GlossSee (string). Check definition.");
        }
    }

//ll1gen::field_istream_end

        if('}' == ll1gen::json::detail::lookUpAndEat(__stream, "},")) {
            break;
        }
    }
    return __stream;
}

} } 

#endif

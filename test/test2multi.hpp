//
// GENERATED by ll1gen : Do not modify (or on your own risk)
//
#ifndef _LL1GEN_TEST2MULTI_HPP_
#define _LL1GEN_TEST2MULTI_HPP_

#include "json_utils.hpp"

//ll1gen::include_begin

#include "test2simple.hpp"
//ll1gen::include_end

namespace test { 

class Test2Multi {
public:
    //ll1gen::constructor_begin

    //ll1gen::constructor_end
    Test2Multi() {}
    ~Test2Multi() {}

#ifndef LL1GEN_DISABLE_STANDARD_GETTERS
    //ll1gen::getters_begin

    
    std::vector<bool>  get_multiBool() const { return _multiBool; }

    void set_multiBool( const std::vector<bool>  & __val) { _multiBool = __val; }



    std::vector<std::string>  get_multiString() const { return _multiString; }

    void set_multiString( const std::vector<std::string>  & __val) { _multiString = __val; }



    std::vector<int>  get_multiInt() const { return _multiInt; }

    void set_multiInt( const std::vector<int>  & __val) { _multiInt = __val; }



    std::vector<Test2Simple>  get_multiObj() const { return _multiObj; }

    void set_multiObj( const std::vector<Test2Simple>  & __val) { _multiObj = __val; }


//ll1gen::getters_end
#endif

#ifndef LL1GEN_DISABLE_REFERENCE_GETTERS
    //ll1gen::ref_getters_begin

        std::vector<bool>  & multiBool() { return _multiBool; }


    std::vector<std::string>  & multiString() { return _multiString; }


    std::vector<int>  & multiInt() { return _multiInt; }


    std::vector<Test2Simple>  & multiObj() { return _multiObj; }


//ll1gen::ref_getters_end
#endif

    friend std::ostream& operator<< (std::ostream& __stream, const Test2Multi& __bean);
    friend std::istream& operator>> (std::istream& __stream, Test2Multi& __bean);
private:
    //ll1gen::field_decl_begin

    std::vector<bool>  _multiBool;
std::vector<std::string>  _multiString;
std::vector<int>  _multiInt;
std::vector<Test2Simple>  _multiObj;
//ll1gen::field_decl_end
};

std::ostream& operator<< (std::ostream& __stream, const Test2Multi& __bean) {
    __stream << "{";
    //ll1gen::field_ostream_begin

        __stream << "[";
    for(unsigned int __index = 0; __index < __bean._multiBool.size() - 1; ++__index) {
        auto & __item = __bean._multiBool.at(__index);
        __stream << (__item ? "true" : "false");
        __stream << ",";
    }
    if(__bean._multiBool.size()) {
        __stream << (__bean._multiBool.at(__bean._multiBool.size() - 1) ? "true" : "false");
    }
    __stream << "]";


__stream << ",";
    __stream << "[";
    for(unsigned int __index = 0; __index < __bean._multiString.size() - 1; ++__index) {
        auto & __item = __bean._multiString.at(__index);
        __stream << "\"" << ll1gen::json::encodeJsonString(__item) << "\"";
        __stream << ",";
    }
    if(__bean._multiString.size()) {
        __stream << "\"" << ll1gen::json::encodeJsonString(__bean._multiString.at(__bean._multiString.size() - 1)) << "\"";
    }
    __stream << "]";


__stream << ",";
    __stream << "[";
    for(unsigned int __index = 0; __index < __bean._multiInt.size() - 1; ++__index) {
        auto & __item = __bean._multiInt.at(__index);
        __stream << __item;
        __stream << ",";
    }
    if(__bean._multiInt.size()) {
        __stream << __bean._multiInt.at(__bean._multiInt.size() - 1);
    }
    __stream << "]";


__stream << ",";
    __stream << "[";
    for(unsigned int __index = 0; __index < __bean._multiObj.size() - 1; ++__index) {
        auto & __item = __bean._multiObj.at(__index);
        __stream << __item;
        __stream << ",";
    }
    if(__bean._multiObj.size()) {
        __stream << __bean._multiObj.at(__bean._multiObj.size() - 1);
    }
    __stream << "]";


//ll1gen::field_ostream_end
    __stream << "}";
    return __stream;
}

std::istream& operator>> (std::istream& __stream, Test2Multi& __bean) {
    char __startObjectMrk = ll1gen::json::lookUpAndEat(__stream, "{n");
    if(__startObjectMrk == 'n') {
        ll1gen::json::lookUpTokenRemainder(__stream, __startObjectMrk, "null");
        return __stream;
    }
    for(unsigned int __i = 0; __i < 4; ++__i) {
        ll1gen::json::lookUpAndEat(__stream, "\"");
        std::string __propertyName = ll1gen::json::lookUp(__stream, "\"");
        ll1gen::json::lookUpAndEat(__stream, ":");

        //ll1gen::field_istream_begin

            
    if(__propertyName == "multiBool") {
        ll1gen::json::lookUpAndEat(__stream, "[");
        while(1) {
            bool __item;
            if(!ll1gen::json::parseBool(__stream, __item)) {
                throw std::runtime_error("JSON: null is not supported for multiBool (vector/bool). Check definition.");
            }
            __bean._multiBool.push_back(__item);
            char nextChar = ll1gen::json::lookUpAndEat(__stream, ",]");
            if(nextChar == ']') { break; }
        }
    }

else
    
    if(__propertyName == "multiString") {
        ll1gen::json::lookUpAndEat(__stream, "[");
        while(1) {
            std::string __item;
            if(!ll1gen::json::parseString(__stream, __item)) {
                throw new std::runtime_error("JSON: null not supported for field multiString (vector/string). Check definition.");
            }
            __bean._multiString.push_back(std::move(__item));
            char nextChar = ll1gen::json::lookUpAndEat(__stream, ",]");
            if(nextChar == ']') { break; }
        }
    }

else
    
    if(__propertyName == "multiInt") {
        ll1gen::json::lookUpAndEat(__stream, "[");
        while(1) {
            std::vector<int>  __item;
            if(!ll1gen::json::lookUpNull(__stream)) {
                __stream >> __item;
            } else {
                throw std::runtime_error("JSON: null not supported for field multiInt (vector). Check definition");
            }
            __bean._multiInt.push_back(std::move(__item));
            char nextChar = ll1gen::json::lookUpAndEat(__stream, ",]");
            if(nextChar == ']') { break; }
        }
    }

else
    
    if(__propertyName == "multiObj") {
        ll1gen::json::lookUpAndEat(__stream, "[");
        while(1) {
            std::vector<Test2Simple>  __item;
            if(!ll1gen::json::lookUpNull(__stream)) {
                __stream >> __item;
            } else {
                throw std::runtime_error("JSON: null not supported for field multiObj (vector). Check definition");
            }
            __bean._multiObj.push_back(std::move(__item));
            char nextChar = ll1gen::json::lookUpAndEat(__stream, ",]");
            if(nextChar == ']') { break; }
        }
    }

//ll1gen::field_istream_end

        if('{' == ll1gen::json::lookUpAndEat(__stream, "},")) {
            break;
        }
    }
    return __stream;
}

} 

#endif
